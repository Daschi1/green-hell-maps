name: Build and Publish Docker Image

# Trigger this workflow on any push to the "main" branch.
on:
  push:
    branches: [ "main" ]

# Define environment variables that will be used throughout the workflow.
env:
  # The Docker registry to push images to. Default is GitHub Container Registry (ghcr.io).
  REGISTRY: ghcr.io
  # The name of the Docker image, derived from the repository name.
  IMAGE_NAME: ${{ github.repository }}

# The jobs section defines the sequence of tasks to be run in this workflow.
jobs:
  build:
    # Specify the type of virtual environment to use. 'ubuntu-latest' is commonly used for most workflows.
    runs-on: ubuntu-latest

    # Define the permissions required by this job.
    permissions:
      contents: read      # Grants read access to the repository contents.
      packages: write     # Grants write access to the package registry.

    # Steps are individual tasks that are executed sequentially within the job.
    steps:
      # Step 1: Check out the repository code.
      - name: Checkout repository
        uses: actions/checkout@v4
        # The 'actions/checkout' action clones the repository's code onto the runner.

      # Step 2: Extract version information from package.json.
      - name: Extract version from package.json
        id: version  # Assigns an ID to this step for referencing its outputs later.
        run: |
          # Extract full version (e.g., 1.2.3) from package.json.
          MAJOR_MINOR_PATCH=$(grep '"version":' package.json | cut -d '"' -f 4)
          # Extract major.minor version (e.g., 1.2).
          MAJOR_MINOR=$(echo $MAJOR_MINOR_PATCH | cut -d '.' -f1-2)
          # Extract major version (e.g., 1).
          MAJOR=$(echo $MAJOR_MINOR_PATCH | cut -d '.' -f1)
          # Store extracted versions as environment variables for use in later steps.
          echo "MAJOR_MINOR_PATCH=$MAJOR_MINOR_PATCH" >> $GITHUB_ENV
          echo "MAJOR_MINOR=$MAJOR_MINOR" >> $GITHUB_ENV
          echo "MAJOR=$MAJOR" >> $GITHUB_ENV

      # Step 3: Set up Docker Buildx for building multi-platform Docker images.
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        # The 'docker/setup-buildx-action' action sets up Docker Buildx, a tool for building Docker images.

      # Step 4: Log in to the Docker registry using credentials.
      - name: Log into registry ${{ env.REGISTRY }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}  # Use the registry defined in the environment variable.
          username: ${{ github.actor }}  # Use the GitHub actor (user) as the username.
          password: ${{ secrets.GITHUB_TOKEN }}  # Use the GitHub token as the password.

      # Step 5: Extract Docker image metadata, such as tags and labels, based on the version extracted earlier.
      - name: Extract Docker metadata
        id: meta  # Assigns an ID to this step for referencing its outputs later.
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            # Tag the image with 'latest', full version, major.minor version, and major version.
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.MAJOR_MINOR_PATCH }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.MAJOR_MINOR }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.MAJOR }}

      # Step 6: Build and push the Docker image to the registry.
      - name: Build and push Docker image
        id: build-and-push  # Assigns an ID to this step for referencing its outputs later.
        uses: docker/build-push-action@v5
        with:
          context: .  # The context is the root of the repository.
          push: true  # Push the image to the registry after building it.
          tags: ${{ steps.meta.outputs.tags }}  # Use the tags generated in the previous step.
          labels: ${{ steps.meta.outputs.labels }}  # Use the labels generated in the previous step.
          cache-from: type=gha  # Use GitHub Actions cache to speed up builds.
          cache-to: type=gha,mode=max  # Store the cache in GitHub Actions for reuse.

      # Step 7: Sign the published Docker image using Cosign, ensuring its authenticity and integrity.
      - name: Sign the published Docker image
        env:
          TAGS: ${{ steps.meta.outputs.tags }}  # Use the tags generated earlier.
          DIGEST: ${{ steps.build-and-push.outputs.digest }}  # Use the digest of the built image.
        run: echo "${TAGS}" | xargs -I {} cosign sign --yes {}@${DIGEST}
        # The 'cosign sign' command signs the Docker image, ensuring it hasn't been tampered with.
